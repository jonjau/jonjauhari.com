{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/monads-applicatives-and-functors-in-haskell/","result":{"data":{"site":{"siteMetadata":{"title":"Jonathan Jauhari"}},"markdownRemark":{"id":"b92cb5e3-d5fd-532f-bb02-374ab3477e3f","excerpt":"This is my summary of Chapter 11 and 12 of\nLearn You a Haskell for Great Good!,\na great introduction to functional programming and Haskell. I’ve found its…","html":"<p>This is my summary of Chapter 11 and 12 of\n<a href=\"http://learnyouahaskell.com/chapters\">Learn You a Haskell for Great Good!</a>,\na great introduction to functional programming and Haskell. I’ve found its\nexplanation of monads, by far the most notorious of category theory jargon\n(monoids and functors being runner-ups), to be about as intuitive as monad\nexplanations can get.</p>\n<p>This is hardly comprehensive, but these notes touch on most of the main\nconcepts of the Haskell type system (that I’m aware of…).</p>\n<h2>Values</h2>\n<p>Values have types. Types can be inferred:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token char string\">'f'</span>       <span class=\"token comment\">-- x has (inferred) type Char</span>\n<span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token char string\">'f'</span><span class=\"token punctuation\">,</span><span class=\"token char string\">'g'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">-- y has (inferred) type [Char], a list of Char's</span></code></pre></div>\n<p>Use <code class=\"language-text\">:t</code> in <a href=\"https://docs.haskellstack.org/en/stable/ghci/\">GHCi</a>\nto check the type of a value, e.g. <code class=\"language-text\">:t &#39;f&#39;</code> will give <code class=\"language-text\">f :: Char</code>, where\n<code class=\"language-text\">::</code> can be read as ‘type of’ or ‘has type’. There is also\n<a href=\"%5Bhoogle.com%5D(https://hoogle.haskell.org)\">Hoogle</a>.\nThough Haskell is able to infer types very well, it is good practice that\ntop-level definitions are explicitly type-annotated:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- the type declaration doesn't have to sit on top of the definition either</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Char</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token char string\">'f'</span></code></pre></div>\n<h2>Functions</h2>\n<p>Functions map values to values. Since functions themselves are values\n(<a href=\"https://en.wikipedia.org/wiki/First-class_citizen\">“first-class citizens”</a>),\nthey too have types. <code class=\"language-text\">f :: p -&gt; p</code> can be read as “f takes a p and returns a p”.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">p</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span>\n<span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>            <span class=\"token comment\">-- no-op</span>\n\n<span class=\"token hvariable\">g</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">g</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y</span>      <span class=\"token comment\">-- equality, g is pretty much (==)</span></code></pre></div>\n<p>The second function <code class=\"language-text\">g</code> has a type constraint: it takes two arguments of a type\n<code class=\"language-text\">a</code> that must have properly defined equality, such that it is of the\ntypeclass <code class=\"language-text\">Eq</code> (more on this later), e.g. <code class=\"language-text\">Int</code>. This is parametric\npolymorphism, with especially lightweight syntax.</p>\n<p>Note functions in Haskell are automatically\n<a href=\"https://en.wikipedia.org/wiki/Currying\">curried</a> (like partial application,\nbut one argument at at time) — a function that takes two arguments, like <code class=\"language-text\">g</code>,\nis still a valid function when only one of its arguments is given:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- (g 3) is a function that expects one argument, and returns true if it equals</span>\n<span class=\"token comment\">-- 3 and false otherwise. This returns all the items equal to 3 in the list:</span>\n<span class=\"token builtin\">filter</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">-- evaluates to [3,3]</span></code></pre></div>\n<h2>Defining (data) types</h2>\n<p><code class=\"language-text\">data</code> defines an algebraic data type\n(<a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">ADT</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">TrafficLight</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Red</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Yellow</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Green</span>\n\n<span class=\"token comment\">-- the value of type Person may be constructed with: Person \"bob\" 9</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">Person</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Person</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Int</span></code></pre></div>\n<p>On the left is the name of the type, and on the right are data constructors\n(or type constructors). Type constructors are like functions: they may take\nparameters and are automatically curried. Types may have the same name as\ntheir data constructor(s). Note that type constructors do not have a function\nbody, they simply construct types.</p>\n<p><code class=\"language-text\">newtype</code> defines new types out of existing data types:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- this is record syntax in Haskell</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">ZipList</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">ZipList</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">getZipList</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">-- faster (no wrapping/unwrapping overhead) and equivalent:</span>\n<span class=\"token keyword\">newtype</span> <span class=\"token constant\">ZipList</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">ZipList</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">getZipList</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>It was made exactly for cases when we want to just take one type and\nwrap it in something to present it as another type.\n<code class=\"language-text\">data</code> can only and should be replaced with <code class=\"language-text\">newtype</code> if the type has exactly\none constructor with exactly one field inside it. Contrast this with:</p>\n<h2>Type synonyms</h2>\n<p><code class=\"language-text\">type</code> defines a type alias. Wherever one can be used, the other can\ntake its place. No data constructor is defined.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">MyStr</span> <span class=\"token operator\">=</span> <span class=\"token constant\">String</span></code></pre></div>\n<h2>Typeclasses</h2>\n<p>A typeclass takes a type variable and describes what can be done to it;\ntypeclasses are like interfaces in languages like Java.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- What does it mean to have well-defined equality?</span>\n<span class=\"token comment\">-- It must define the following functions:</span>\n<span class=\"token keyword\">class</span> <span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">where</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">/=</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n    <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">not</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">/=</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">-- this is the default implementation for (==)</span>\n    <span class=\"token hvariable\">x</span> <span class=\"token operator\">/=</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">not</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">-- and for (/=), note the indirect recursion.</span></code></pre></div>\n<p>Typeclasses allow for polymorphism:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- constraints check out: 'equal' works for any type a that is an instance of Eq</span>\n<span class=\"token hvariable\">equal</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">equal</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y</span></code></pre></div>\n<p>Types can be made instances of typeclasses:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- How does a TrafficLight have well-defined equality?</span>\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Eq</span> <span class=\"token constant\">TrafficLight</span> <span class=\"token keyword\">where</span>\n    <span class=\"token constant\">Red</span> <span class=\"token operator\">==</span> <span class=\"token constant\">Red</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n    <span class=\"token constant\">Green</span> <span class=\"token operator\">==</span> <span class=\"token constant\">Green</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n    <span class=\"token constant\">Yellow</span> <span class=\"token operator\">==</span> <span class=\"token constant\">Yellow</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n    <span class=\"token hvariable\">_</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">False</span></code></pre></div>\n<blockquote>\n<p>If you want to see what the instances of a typeclass are, just do <code class=\"language-text\">:info</code>\n(or <code class=\"language-text\">:i</code>) on a typeclass in GHCI. Typing <code class=\"language-text\">:info Num</code> will show which\nfunctions the typeclass defines and it will give you a list of the types in\nthe typeclass. <code class=\"language-text\">:info</code> works for types and type constructors too.</p>\n</blockquote>\n<h2>Monoids</h2>\n<p>A monoid is a type for which you have a well-defined associative binary\nfunction e.g. <code class=\"language-text\">(*)</code> in <code class=\"language-text\">(1*(2*3) == (1*2)*3)</code> and a value which acts as an\nidentity with respect to that function. When something acts as an identity\nwith respect to a function, it means that when called with that function and\nsome other value, the result is always equal to that other value:</p>\n<blockquote>\n<p><code class=\"language-text\">1</code> is the identity with respect to <code class=\"language-text\">*</code>\nand <code class=\"language-text\">[]</code> is the identity with respect to <code class=\"language-text\">++</code>.\nAny number multiplied by 1 is itself, and appending the empty list to any\nlist yields the list. So <code class=\"language-text\">1</code> and <code class=\"language-text\">[]</code> are <code class=\"language-text\">mempty</code>s and <code class=\"language-text\">*</code> and <code class=\"language-text\">++</code> are\n<code class=\"language-text\">mappend</code>s for the <code class=\"language-text\">Num</code> and <code class=\"language-text\">[]</code> monoids, respectively.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Monoid</span> <span class=\"token hvariable\">m</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">mempty</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">m</span> <span class=\"token comment\">-- polymorphic constant: the identity value (e.g. 1 w.r.t *)</span>\n    <span class=\"token hvariable\">mappend</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">m</span> <span class=\"token comment\">-- takes two monoid values and returns a third</span>\n    <span class=\"token hvariable\">mconcat</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">m</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">m</span>\n    <span class=\"token hvariable\">mconcat</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">mappend</span> <span class=\"token hvariable\">mempty</span> <span class=\"token comment\">-- default implementation!</span></code></pre></div>\n<p>Monoid laws (surrounding a function with backticks (`) allows infix calling):</p>\n<ul>\n<li><code class=\"language-text\">mempty `mappend` x = x</code></li>\n<li><code class=\"language-text\">x `mappend` mempty = x</code></li>\n<li><code class=\"language-text\">(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></li>\n</ul>\n<p>Monoid instances:</p>\n<ul>\n<li>lists are monoids, where <code class=\"language-text\">mempty = []</code>, <code class=\"language-text\">mappend = (++)</code></li>\n<li>numbers can be monoids in multiple ways with <code class=\"language-text\">0</code> and <code class=\"language-text\">+</code>, and <code class=\"language-text\">1</code> and <code class=\"language-text\">*</code></li>\n<li>booleans can be monoids in two ways with <code class=\"language-text\">False</code> and <code class=\"language-text\">OR</code> (<code class=\"language-text\">newtype</code>‘d as <code class=\"language-text\">Any</code>\nin <code class=\"language-text\">Data.Monoid</code>), and <code class=\"language-text\">True</code> and <code class=\"language-text\">AND</code>\n(<code class=\"language-text\">newtype</code>‘d as <code class=\"language-text\">All</code> in <code class=\"language-text\">Data.Monoid</code>).</li>\n</ul>\n<h2>Functors</h2>\n<p>What can I map functions over? I can map functions over a\n“computational context”.</p>\n<ul>\n<li>functors are things that can be mapped over (e.g. lists, Maybes).</li>\n<li>functors are instances of the typeclass <code class=\"language-text\">Functor</code>.</li>\n<li><code class=\"language-text\">fmap</code> works like <code class=\"language-text\">map</code>, but is more general (works on all functors, not\njust lists).</li>\n<li><code class=\"language-text\">(&lt;$&gt;)</code> is an infix synonym of <code class=\"language-text\">fmap</code>.</li>\n<li>“normal” functors support mapping “normal” functions over them.\n“normal” here meaning dealing with plain old values, i.e. non-monadic\nvalues.</li>\n</ul>\n<p>Technically any type can be defined to be a Functor, whether it makes sense\nis a separate issue. Examples of where it makes sense:</p>\n<ul>\n<li>mapping a function over a list of <code class=\"language-text\">a</code>s means applying the function to each\n<code class=\"language-text\">a</code> in the list. The computational context here is the “repetition”.</li>\n<li>mapping a function over a <code class=\"language-text\">Maybe a</code>, means applying the function to the <code class=\"language-text\">a</code>\nif it’s there, or evaluating to <code class=\"language-text\">Nothing</code> if it’s not.\nThe computational context here is the “optionality”.</li>\n</ul>\n<blockquote>\n<p>A <code class=\"language-text\">Maybe a</code> is either a <code class=\"language-text\">Just a</code> or a <code class=\"language-text\">Nothing</code> — it has two data\nconstructors.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- these two expressions are equivalent, they both evaluate to [4,5,6,7,8]</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">-- a Maybe supports mapping (+3), a normal function as follows:</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">-- evaluates to (Just 8)</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token constant\">Nothing</span>   <span class=\"token comment\">-- evaluates to Nothing</span></code></pre></div>\n<blockquote>\n<p>Note how the values end up inside the context (wrapped in the List/Maybe).\nIn general there is not a nice function you can use to recover the <code class=\"language-text\">a</code> once\nit is inside a functor (or an <code class=\"language-text\">Applicative</code>, or a <code class=\"language-text\">Monad</code>). That is,\n<code class=\"language-text\">Functor</code> does not require its instances to define what it means to unwrap\na the context to return the value.</p>\n<p>This is by design. For instance, unwrapping a <code class=\"language-text\">Maybe</code> to try and get the value\ninside of it doesn’t always make sense: what would <code class=\"language-text\">Nothing</code> unwrap into?\n<strong>… NullPointerException</strong>. In the case of the <code class=\"language-text\">IO</code> monad, whose\ncomputational context I think of as “impurity”, it is even more finicky to\nextract a pure value from a monadic one. In any case you will invite\nruntime errors.</p>\n</blockquote>\n<p>Anyway, here are the Functor laws:</p>\n<ol>\n<li><code class=\"language-text\">fmap id = id</code>, where <code class=\"language-text\">id</code> is <code class=\"language-text\">\\x -&gt; x</code>: “return what was passed”</li>\n<li><code class=\"language-text\">fmap (f . g) = fmap f . fmap g</code>, or equivalently, <br>\n<code class=\"language-text\">fmap (f . g) F = fmap f (fmap g F)</code>.</li>\n</ol>\n<p>The <code class=\"language-text\">\\x y -&gt; x + y</code> syntax is a lambda expression, here it defines an\nanonymous function that takes two arguments x and y and returns their sum.\nThe <code class=\"language-text\">.</code> syntax is\n<a href=\"https://en.wikipedia.org/wiki/Function_composition\">function composition</a> as\nin mathematics: <code class=\"language-text\">(f . g) x</code> is equivalent to <code class=\"language-text\">f (g x)</code>.</p>\n<h2>Applicative functors</h2>\n<p>What if I want to map normal functions in a functor over another functor:\n“to reach into the context, compute, and return the value in that context”?\nThose functors must be applicative.</p>\n<blockquote>\n<ul>\n<li>applicative values are values with “added context”, e.g. <code class=\"language-text\">Just 5</code></li>\n<li>applicative functors support mapping functions inside functors over them</li>\n<li>applicative functors are functors, and they are instances of the\n<code class=\"language-text\">Applicative</code> typeclass. It defines <code class=\"language-text\">pure</code> and <code class=\"language-text\">(&lt;*&gt;)</code>.</li>\n<li><code class=\"language-text\">pure</code> takes a value and returns that value in the applicative functor\n(“wrapped in the minimal context”)</li>\n<li><code class=\"language-text\">&lt;*&gt;</code> (infix) takes a functor with a function in it and another functor,\nand extracts the function from the first functor and maps it over the\nsecond one.</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- mapping functions in a functor over values in a functor</span>\n<span class=\"token comment\">-- (the same type of functor!)</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">-- [4,5,6,7,0,-1,-2,-3,1,4,9,16]</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token operator\">==</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>            <span class=\"token comment\">-- [False, False, True, False]</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;*></span> <span class=\"token constant\">Nothing</span>    <span class=\"token comment\">-- Nothing</span>\n<span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token operator\">-</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">-- Just (-4)</span>\n<span class=\"token constant\">Nothing</span> <span class=\"token operator\">&lt;*></span> <span class=\"token constant\">Nothing</span>        <span class=\"token comment\">-- Nothing</span></code></pre></div>\n<p>Applicative functor laws (this is where the analogies fall apart):</p>\n<ol>\n<li><code class=\"language-text\">pure id &lt;*&gt; v = v</code></li>\n<li><code class=\"language-text\">pure f &lt;*&gt; pure x = pure (f x)</code></li>\n<li><code class=\"language-text\">u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></li>\n<li><code class=\"language-text\">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></li>\n</ol>\n<h2>Monads</h2>\n<p>What if I have a value in a context, <code class=\"language-text\">m a</code>, and want apply to it a function\nthat takes a normal <code class=\"language-text\">a</code> and returns a value in that context?\nHow do you apply a function of type <code class=\"language-text\">a -&gt; m b</code> to a value of type <code class=\"language-text\">m a</code>?</p>\n<p>Another take on monads from a similarly great book:\n<a href=\"http://book.realworldhaskell.org/read/monads.html\">a programmable semicolon</a>.</p>\n<blockquote>\n<ul>\n<li>monads are just applicative functors that support <code class=\"language-text\">&gt;&gt;=</code> (read as “bind”)</li>\n<li><code class=\"language-text\">&gt;&gt;=</code> is like function application, only instead of taking a normal value\nand feeding it to a normal function, it takes a monadic value (that is,\na value with a context) and feeds it to a function that takes a normal\nvalue but returns a monadic value.</li>\n<li>a <code class=\"language-text\">Monad</code>’s <code class=\"language-text\">return</code> is the same as an <code class=\"language-text\">Applicative</code>’s <code class=\"language-text\">pure</code>,\njust a different name.</li>\n</ul>\n</blockquote>\n<p>The most useful monad: the <code class=\"language-text\">IO</code> monad (again, it is also an Applicative and a\nFunctor). Sequencing operations one after the other (functions) is possible\nin the IO monad. This looks like imperative programming and is indeed necessary\nwhen dealing with IO operations, which are inherently\n<a href=\"https://en.wikipedia.org/wiki/Functional_purity\">impure</a>.</p>\n<p>In a way, since the fact that potential side effects from the <code class=\"language-text\">IO</code> operations\nare clearly in laid out in the type system, they are not really side effects,\nand this makes the whole program easier to reason with. It is said that this\nmakes Haskell a purely functional language still.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- we can finally write Hello World :)</span>\n<span class=\"token comment\">-- f >> g is the same as f >>= \\_ -> g</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">::</span> <span class=\"token constant\">IO</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">=</span>\n    <span class=\"token builtin\">putStr</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token operator\">>>=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">_</span> <span class=\"token operator\">-></span>\n        <span class=\"token builtin\">putStr</span> <span class=\"token string\">\" ...World\"</span> <span class=\"token operator\">>></span>\n            <span class=\"token builtin\">putStrLn</span> <span class=\"token string\">\"in Haskell\"</span>\n\n<span class=\"token comment\">-- demonstrating the I in IO, as well as monad syntax:</span>\n<span class=\"token comment\">-- a function that fetches user input, prints it out and returns it.</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">::</span> <span class=\"token constant\">IO</span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">=</span>\n    <span class=\"token builtin\">putStrLn</span> <span class=\"token string\">\"Who?\"</span> <span class=\"token operator\">>></span>\n        <span class=\"token builtin\">getLine</span> <span class=\"token operator\">>>=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">name</span> <span class=\"token operator\">-></span>\n            <span class=\"token builtin\">putStrLn</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"Oh Hello \"</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">name</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span>\n                <span class=\"token builtin\">return</span> <span class=\"token hvariable\">name</span></code></pre></div>\n<p>The distinction with applicative functors is very slight.\n<strong>Most common functors are applicative and are monads</strong>, e.g.\n<code class=\"language-text\">[]</code>, <code class=\"language-text\">Maybe</code>, <code class=\"language-text\">State</code>, <code class=\"language-text\">IO</code></p>\n<p><a href=\"https://en.wikibooks.org/wiki/Haskell/do_notation\">do-blocks</a>\nare syntactic sugar to deal with monads, to do away with nesting. See below.</p>\n<h2>Syntax</h2>\n<p>To make a point about the syntax, all of these functions are exactly equivalent:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- list comprehension</span>\n<span class=\"token comment\">-- lists get their own special shorthand syntax, comprehensions like in Python.</span>\n<span class=\"token hvariable\">e1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">e1</span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">in</span>  <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">lst</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">lst</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">-- do-block: \"implicit\" (>>=)'s</span>\n<span class=\"token hvariable\">e2</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">e2</span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">lst</span>\n    <span class=\"token hvariable\">y</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">lst</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n    <span class=\"token builtin\">return</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- sugarless: binding monadic operations explicitly</span>\n<span class=\"token hvariable\">e3</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">e3</span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span> <span class=\"token keyword\">in</span>\n    <span class=\"token hvariable\">lst</span> <span class=\"token operator\">>>=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span>\n        <span class=\"token hvariable\">lst</span> <span class=\"token operator\">>>=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">y</span> <span class=\"token operator\">-></span>\n            <span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- maximum golf: remember (&lt;*>) :: Applicative f => f (a -> b) -> f a -> f b</span>\n<span class=\"token comment\">-- implicitly the &lt;$> bit is evaluated first to get a list of functions.</span>\n<span class=\"token hvariable\">e4</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">e4</span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span> <span class=\"token keyword\">in</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">lst</span></code></pre></div>\n<h2>Types and instances of functors et al</h2>\n<ul>\n<li><code class=\"language-text\">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>, literally <code class=\"language-text\">fmap</code> but just for lists</li>\n<li><code class=\"language-text\">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is a functor :@1</li>\n<li><code class=\"language-text\">(&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is a functor</li>\n<li><code class=\"language-text\">pure :: a -&gt; f a</code>, where f is an applicative functor</li>\n<li><code class=\"language-text\">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is an applicative functor</li>\n<li><code class=\"language-text\">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code>, where m is a monad</li>\n<li><code class=\"language-text\">(&gt;&gt;) :: m a -&gt; m b -&gt; m b</code>, where m is a monad</li>\n<li><code class=\"language-text\">return :: a -&gt; m a</code>, where m is a monad</li>\n</ul>\n<p><a href=\"https://wiki.haskell.org/Lifting\">“lifting”</a>:\n<code class=\"language-text\">(-&gt;)</code> is right-applicative, so\n<code class=\"language-text\">fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code> is equivalent, and emphasises the “lift”,\nlikewise for <code class=\"language-text\">pure</code> et al.</p>\n<p>this is how lists are instances of Functor:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- [] here is A TYPE CONSTRUCTOR, i.e. the f in Functor f</span>\n<span class=\"token comment\">-- not the literal for an empty list.</span>\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span></code></pre></div>\n<p>and Maybe:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Maybe</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code></pre></div>\n<p>and Either:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span>\n\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">x</span></code></pre></div>\n<p><code class=\"language-text\">Either a</code> is a type constructor that takes 1 parameter, which is what the\nFunctor typeclass expects.</p>\n<p>Functions are in fact monads too:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Applicative</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">pure</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">_</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token hvariable\">f</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token number\">5</span>\n<span class=\"token number\">508</span></code></pre></div>\n<h2>In action</h2>\n<p>Golfing once again…</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- equivalently:</span>\n<span class=\"token comment\">-- getZipList $ fmap (+) (ZipList [1,2,3]) &lt;*> (ZipList [100,10,20])</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token hvariable\">getZipList</span> <span class=\"token operator\">$</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token constant\">ZipList</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;*></span> <span class=\"token constant\">ZipList</span> <span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">101</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">-- implicitly, this is (fmap &lt;$> [(+2,(*2))]) &lt;*> [Just 10, Just 20] :@1</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">fmap</span> <span class=\"token operator\">&lt;$></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Just</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Just</span> <span class=\"token number\">20</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">Just</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Just</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Just</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Just</span> <span class=\"token number\">40</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Just</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Nothing</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Just</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">Just</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Nothing</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Just</span> <span class=\"token number\">6</span><span class=\"token punctuation\">]</span></code></pre></div>\n<h2>Class constraints</h2>\n<p>Class constraints can appear in (type)class declarations vs instance\ndeclarations, as in <code class=\"language-text\">(Eq m) =&gt; Eq (classOrInstanceName m)</code>.</p>\n<ul>\n<li>In class declarations, they are used for making a typeclass a subclass of\nanother typeclass.</li>\n<li>In instance declarations, they are used to express requirements about the\ncontents of some type.</li>\n</ul>\n<p>For instance, we might require the contents of a Maybe, which is a concrete\ntype to also be part of the Eq typeclass. Note the Maybe is a type constructor.</p>\n<h2>Kinds</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Kind_(type_theory)\">Few languages</a>\nhave type systems that allow access to higher-kinded types (e.g. Monads).\nHaskell lets you see the kinds of types too. I have yet to realise where\nthis might be useful.</p>\n<p>Kinds are to types what types are to values. Find out kind of a type with\n<code class=\"language-text\">:k</code> in GHCi.</p>\n<p><code class=\"language-text\">*</code> means concrete type:</p>\n<ul>\n<li><code class=\"language-text\">Int :: *</code></li>\n<li><code class=\"language-text\">Maybe :: * -&gt; *</code></li>\n<li><code class=\"language-text\">Maybe Int :: *</code></li>\n<li><code class=\"language-text\">Either :: * -&gt; * -&gt; *</code></li>\n</ul>\n<p>I haven’t quite grasped this, but it’s interesting regardless:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Tofu</span> <span class=\"token hvariable\">t</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">tofu</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">j</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">j</span></code></pre></div>\n<p>If <code class=\"language-text\">t</code> is an instance of <code class=\"language-text\">Tofu</code>, what would its kind be?</p>\n<ul>\n<li><code class=\"language-text\">j a</code> is the type of the value of the first parameter of <code class=\"language-text\">tofu</code>, so\nits kind must be <code class=\"language-text\">*</code>, i.e. it is a concrete type.</li>\n<li>Assuming <code class=\"language-text\">a</code> is of kind <code class=\"language-text\">*</code>, <code class=\"language-text\">j</code> has kind <code class=\"language-text\">* -&gt; *</code>.</li>\n<li><code class=\"language-text\">t a j</code> must be a concrete type, and since it takes two types <code class=\"language-text\">a</code> and <code class=\"language-text\">j</code>,\nwhose kinds we inferred above, <code class=\"language-text\">t</code> has kind <code class=\"language-text\">* -&gt; (* -&gt; *) -&gt; *</code>.</li>\n</ul>\n<p>So, <code class=\"language-text\">t</code> takes a concrete type <code class=\"language-text\">a</code>, a type constructor <code class=\"language-text\">j</code> that takes a concrete\ntype, and produces a concrete type.</p>","frontmatter":{"title":"Monads, Applicatives, and Functors in Haskell","date":"October 07, 2020","description":"A summary of monads, applicatives, and functors in Haskell."}},"previous":null,"next":{"fields":{"slug":"/a-sudoku-solver-in-15-lines-of-prolog/"},"frontmatter":{"title":"A Sudoku Solver in 15 Lines of Prolog"}}},"pageContext":{"id":"b92cb5e3-d5fd-532f-bb02-374ab3477e3f","previousPostId":null,"nextPostId":"c1755bc9-3c36-54c1-8753-d853166fc885"}},"staticQueryHashes":["2841359383"]}