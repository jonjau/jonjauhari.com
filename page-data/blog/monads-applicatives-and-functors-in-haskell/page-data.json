{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/monads-applicatives-and-functors-in-haskell/","result":{"data":{"site":{"siteMetadata":{"title":"Jonathan Jauhari"}},"markdownRemark":{"id":"b92cb5e3-d5fd-532f-bb02-374ab3477e3f","excerpt":"This is my summary of Chapter 11 and 12 of\nLearn You a Haskell for Great Good!,\na great introduction to functional programming and Haskell. I’ve found its…","html":"<p>This is my summary of Chapter 11 and 12 of\n<a href=\"http://learnyouahaskell.com/chapters\">Learn You a Haskell for Great Good!</a>,\na great introduction to functional programming and Haskell. I’ve found its\nexplanation of monads, by far the most notorious of category theory jargon\n(monoids and functors being runner-ups), to be about as intuitive as monad\nexplanations can get.</p>\n<p>This is hardly comprehensive, but these notes touch on most of the main\nconcepts of the Haskell type system (that I’m aware of…).</p>\n<h2>Values</h2>\n<p>Values have types. Types can be inferred:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token char string\">'f'</span>       <span class=\"token comment\">-- x has (inferred) type Char</span>\n<span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token char string\">'f'</span><span class=\"token punctuation\">,</span><span class=\"token char string\">'g'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">-- y has (inferred) type [Char], a list of Char's</span></code></pre></div>\n<p>Use <code>:t</code> in <a href=\"https://docs.haskellstack.org/en/stable/ghci/\">GHCi</a>\nto check the type of a value, e.g. <code>:t 'f'</code> will give <code>f :: Char</code>, where\n<code>::</code> can be read as ‘type of’ or ‘has type’. There is also\n<a href=\"%5Bhoogle.com%5D(https://hoogle.haskell.org)\">Hoogle</a>.\nThough Haskell is able to infer types very well, it is good practice that\ntop-level definitions are explicitly type-annotated:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- the type declaration doesn't have to sit on top of the definition either</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Char</span>\n<span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token char string\">'f'</span></code></pre></div>\n<h2>Functions</h2>\n<p>Functions map values to values. Since functions themselves are values\n(<a href=\"https://en.wikipedia.org/wiki/First-class_citizen\">“first-class citizens”</a>),\nthey too have types. <code>f :: p -> p</code> can be read as “f takes a p and returns a p”.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">p</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">p</span>\n<span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>            <span class=\"token comment\">-- no-op</span>\n\n<span class=\"token hvariable\">g</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">g</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y</span>      <span class=\"token comment\">-- equality, g is pretty much (==)</span></code></pre></div>\n<p>The second function <code>g</code> has a type constraint: it takes two arguments of a type\n<code>a</code> that must have properly defined equality, such that it is of the\ntypeclass <code>Eq</code> (more on this later), e.g. <code>Int</code>. This is parametric\npolymorphism, with especially lightweight syntax.</p>\n<p>Note functions in Haskell are automatically\n<a href=\"https://en.wikipedia.org/wiki/Currying\">curried</a> (like partial application,\nbut one argument at at time) — a function that takes two arguments, like <code>g</code>,\nis still a valid function when only one of its arguments is given:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- (g 3) is a function that expects one argument, and returns true if it equals</span>\n<span class=\"token comment\">-- 3 and false otherwise. This returns all the items equal to 3 in the list:</span>\n<span class=\"token builtin\">filter</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">-- evaluates to [3,3]</span></code></pre></div>\n<h2>Defining (data) types</h2>\n<p><code>data</code> defines an algebraic data type\n(<a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">ADT</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">TrafficLight</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Red</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Yellow</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Green</span>\n\n<span class=\"token comment\">-- the value of type Person may be constructed with: Person \"bob\" 9</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">Person</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Person</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Int</span></code></pre></div>\n<p>On the left is the name of the type, and on the right are data constructors\n(or type constructors). Type constructors are like functions: they may take\nparameters and are automatically curried. Types may have the same name as\ntheir data constructor(s). Note that type constructors do not have a function\nbody, they simply construct types.</p>\n<p><code>newtype</code> defines new types out of existing data types:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- this is record syntax in Haskell</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">ZipList</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">ZipList</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">getZipList</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">-- faster (no wrapping/unwrapping overhead) and equivalent:</span>\n<span class=\"token keyword\">newtype</span> <span class=\"token constant\">ZipList</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">ZipList</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">getZipList</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>It was made exactly for cases when we want to just take one type and\nwrap it in something to present it as another type.\n<code>data</code> can only and should be replaced with <code>newtype</code> if the type has exactly\none constructor with exactly one field inside it. Contrast this with:</p>\n<h2>Type synonyms</h2>\n<p><code>type</code> defines a type alias. Wherever one can be used, the other can\ntake its place. No data constructor is defined.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">MyStr</span> <span class=\"token operator\">=</span> <span class=\"token constant\">String</span></code></pre></div>\n<h2>Typeclasses</h2>\n<p>A typeclass takes a type variable and describes what can be done to it;\ntypeclasses are like interfaces in languages like Java.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- What does it mean to have well-defined equality?</span>\n<span class=\"token comment\">-- It must define the following functions:</span>\n<span class=\"token keyword\">class</span> <span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">where</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">/=</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n    <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">not</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">/=</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">-- this is the default implementation for (==)</span>\n    <span class=\"token hvariable\">x</span> <span class=\"token operator\">/=</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">not</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\">-- and for (/=), note the indirect recursion.</span></code></pre></div>\n<p>Typeclasses allow for polymorphism:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- constraints check out: 'equal' works for any type a that is an instance of Eq</span>\n<span class=\"token hvariable\">equal</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">equal</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">y</span></code></pre></div>\n<p>Types can be made instances of typeclasses:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- How does a TrafficLight have well-defined equality?</span>\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Eq</span> <span class=\"token constant\">TrafficLight</span> <span class=\"token keyword\">where</span>\n    <span class=\"token constant\">Red</span> <span class=\"token operator\">==</span> <span class=\"token constant\">Red</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n    <span class=\"token constant\">Green</span> <span class=\"token operator\">==</span> <span class=\"token constant\">Green</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n    <span class=\"token constant\">Yellow</span> <span class=\"token operator\">==</span> <span class=\"token constant\">Yellow</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n    <span class=\"token hvariable\">_</span> <span class=\"token operator\">==</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">False</span></code></pre></div>\n<blockquote>\n<p>If you want to see what the instances of a typeclass are, just do <code>:info</code>\n(or <code>:i</code>) on a typeclass in GHCI. Typing <code>:info Num</code> will show which\nfunctions the typeclass defines and it will give you a list of the types in\nthe typeclass. <code>:info</code> works for types and type constructors too.</p>\n</blockquote>\n<h2>Monoids</h2>\n<p>A monoid is a type for which you have a well-defined associative binary\nfunction e.g. <code>(*)</code> in <code>(1*(2*3) == (1*2)*3)</code> and a value which acts as an\nidentity with respect to that function. When something acts as an identity\nwith respect to a function, it means that when called with that function and\nsome other value, the result is always equal to that other value:</p>\n<blockquote>\n<p><code>1</code> is the identity with respect to <code>*</code>\nand <code>[]</code> is the identity with respect to <code>++</code>.\nAny number multiplied by 1 is itself, and appending the empty list to any\nlist yields the list. So <code>1</code> and <code>[]</code> are <code>mempty</code>s and <code>*</code> and <code>++</code> are\n<code>mappend</code>s for the <code>Num</code> and <code>[]</code> monoids, respectively.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Monoid</span> <span class=\"token hvariable\">m</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">mempty</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">m</span> <span class=\"token comment\">-- polymorphic constant: the identity value (e.g. 1 w.r.t *)</span>\n    <span class=\"token hvariable\">mappend</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">m</span> <span class=\"token comment\">-- takes two monoid values and returns a third</span>\n    <span class=\"token hvariable\">mconcat</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">m</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">m</span>\n    <span class=\"token hvariable\">mconcat</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">mappend</span> <span class=\"token hvariable\">mempty</span> <span class=\"token comment\">-- default implementation!</span></code></pre></div>\n<p>Monoid laws (surrounding a function with backticks (`) allows infix calling):</p>\n<ul>\n<li><code>mempty `mappend` x = x</code></li>\n<li><code>x `mappend` mempty = x</code></li>\n<li><code>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></li>\n</ul>\n<p>Monoid instances:</p>\n<ul>\n<li>lists are monoids, where <code>mempty = []</code>, <code>mappend = (++)</code></li>\n<li>numbers can be monoids in multiple ways with <code>0</code> and <code>+</code>, and <code>1</code> and <code>*</code></li>\n<li>booleans can be monoids in two ways with <code>False</code> and <code>OR</code> (<code>newtype</code>‘d as <code>Any</code>\nin <code>Data.Monoid</code>), and <code>True</code> and <code>AND</code>\n(<code>newtype</code>‘d as <code>All</code> in <code>Data.Monoid</code>).</li>\n</ul>\n<h2>Functors</h2>\n<p>What can I map functions over? I can map functions over a\n“computational context”.</p>\n<ul>\n<li>functors are things that can be mapped over (e.g. lists, Maybes).</li>\n<li>functors are instances of the typeclass <code>Functor</code>.</li>\n<li><code>fmap</code> works like <code>map</code>, but is more general (works on all functors, not\njust lists).</li>\n<li><code>(&#x3C;$>)</code> is an infix synonym of <code>fmap</code>.</li>\n<li>“normal” functors support mapping “normal” functions over them.\n“normal” here meaning dealing with plain old values, i.e. non-monadic\nvalues.</li>\n</ul>\n<p>Technically any type can be defined to be a Functor, whether it makes sense\nis a separate issue. Examples of where it makes sense:</p>\n<ul>\n<li>mapping a function over a list of <code>a</code>s means applying the function to each\n<code>a</code> in the list. The computational context here is the “repetition”.</li>\n<li>mapping a function over a <code>Maybe a</code>, means applying the function to the <code>a</code>\nif it’s there, or evaluating to <code>Nothing</code> if it’s not.\nThe computational context here is the “optionality”.</li>\n</ul>\n<blockquote>\n<p>A <code>Maybe a</code> is either a <code>Just a</code> or a <code>Nothing</code> — it has two data\nconstructors.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- these two expressions are equivalent, they both evaluate to [4,5,6,7,8]</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">-- a Maybe supports mapping (+3), a normal function as follows:</span>\n<span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">-- evaluates to (Just 8)</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token constant\">Nothing</span>   <span class=\"token comment\">-- evaluates to Nothing</span></code></pre></div>\n<blockquote>\n<p>Note how the values end up inside the context (wrapped in the List/Maybe).\nIn general there is not a nice function you can use to recover the <code>a</code> once\nit is inside a functor (or an <code>Applicative</code>, or a <code>Monad</code>). That is,\n<code>Functor</code> does not require its instances to define what it means to unwrap\na the context to return the value.</p>\n<p>This is by design. For instance, unwrapping a <code>Maybe</code> to try and get the value\ninside of it doesn’t always make sense: what would <code>Nothing</code> unwrap into?\n<strong>… NullPointerException</strong>. In the case of the <code>IO</code> monad, whose\ncomputational context I think of as “impurity”, it is even more finicky to\nextract a pure value from a monadic one. In any case you will invite\nruntime errors.</p>\n</blockquote>\n<p>Anyway, here are the Functor laws:</p>\n<ol>\n<li><code>fmap id = id</code>, where <code>id</code> is <code>\\x -> x</code>: “return what was passed”</li>\n<li><code>fmap (f . g) = fmap f . fmap g</code>, or equivalently, <br>\n<code>fmap (f . g) F = fmap f (fmap g F)</code>.</li>\n</ol>\n<p>The <code>\\x y -> x + y</code> syntax is a lambda expression, here it defines an\nanonymous function that takes two arguments x and y and returns their sum.\nThe <code>.</code> syntax is\n<a href=\"https://en.wikipedia.org/wiki/Function_composition\">function composition</a> as\nin mathematics: <code>(f . g) x</code> is equivalent to <code>f (g x)</code>.</p>\n<h2>Applicative functors</h2>\n<p>What if I want to map normal functions in a functor over another functor:\n“to reach into the context, compute, and return the value in that context”?\nThose functors must be applicative.</p>\n<blockquote>\n<ul>\n<li>applicative values are values with “added context”, e.g. <code>Just 5</code></li>\n<li>applicative functors support mapping functions inside functors over them</li>\n<li>applicative functors are functors, and they are instances of the\n<code>Applicative</code> typeclass. It defines <code>pure</code> and <code>(&#x3C;*>)</code>.</li>\n<li><code>pure</code> takes a value and returns that value in the applicative functor\n(“wrapped in the minimal context”)</li>\n<li><code>&#x3C;*></code> (infix) takes a functor with a function in it and another functor,\nand extracts the function from the first functor and maps it over the\nsecond one.</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- mapping functions in a functor over values in a functor</span>\n<span class=\"token comment\">-- (the same type of functor!)</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">-</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">-- [4,5,6,7,0,-1,-2,-3,1,4,9,16]</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token operator\">==</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>            <span class=\"token comment\">-- [False, False, True, False]</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;*></span> <span class=\"token constant\">Nothing</span>    <span class=\"token comment\">-- Nothing</span>\n<span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token operator\">-</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">-- Just (-4)</span>\n<span class=\"token constant\">Nothing</span> <span class=\"token operator\">&lt;*></span> <span class=\"token constant\">Nothing</span>        <span class=\"token comment\">-- Nothing</span></code></pre></div>\n<p>Applicative functor laws (this is where the analogies fall apart):</p>\n<ol>\n<li><code>pure id &#x3C;*> v = v</code></li>\n<li><code>pure f &#x3C;*> pure x = pure (f x)</code></li>\n<li><code>u &#x3C;*> pure y = pure ($ y) &#x3C;*> u</code></li>\n<li><code>pure (.) &#x3C;*> u &#x3C;*> v &#x3C;*> w = u &#x3C;*> (v &#x3C;*> w)</code></li>\n</ol>\n<h2>Monads</h2>\n<p>What if I have a value in a context, <code>m a</code>, and want apply to it a function\nthat takes a normal <code>a</code> and returns a value in that context?\nHow do you apply a function of type <code>a -> m b</code> to a value of type <code>m a</code>?</p>\n<p>Another take on monads from a similarly great book:\n<a href=\"http://book.realworldhaskell.org/read/monads.html\">a programmable semicolon</a>.</p>\n<blockquote>\n<ul>\n<li>monads are just applicative functors that support <code>>>=</code> (read as “bind”)</li>\n<li><code>>>=</code> is like function application, only instead of taking a normal value\nand feeding it to a normal function, it takes a monadic value (that is,\na value with a context) and feeds it to a function that takes a normal\nvalue but returns a monadic value.</li>\n<li>a <code>Monad</code>’s <code>return</code> is the same as an <code>Applicative</code>’s <code>pure</code>,\njust a different name.</li>\n</ul>\n</blockquote>\n<p>The most useful monad: the <code>IO</code> monad (again, it is also an Applicative and a\nFunctor). Sequencing operations one after the other (functions) is possible\nin the IO monad. This looks like imperative programming and is indeed necessary\nwhen dealing with IO operations, which are inherently\n<a href=\"https://en.wikipedia.org/wiki/Functional_purity\">impure</a>.</p>\n<p>In a way, since the fact that potential side effects from the <code>IO</code> operations\nare clearly in laid out in the type system, they are not really side effects,\nand this makes the whole program easier to reason with. It is said that this\nmakes Haskell a purely functional language still.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- we can finally write Hello World :)</span>\n<span class=\"token comment\">-- f >> g is the same as f >>= \\_ -> g</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">::</span> <span class=\"token constant\">IO</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">=</span>\n    <span class=\"token builtin\">putStr</span> <span class=\"token string\">\"Hello\"</span> <span class=\"token operator\">>>=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">_</span> <span class=\"token operator\">-></span>\n        <span class=\"token builtin\">putStr</span> <span class=\"token string\">\" ...World\"</span> <span class=\"token operator\">>></span>\n            <span class=\"token builtin\">putStrLn</span> <span class=\"token string\">\"in Haskell\"</span>\n\n<span class=\"token comment\">-- demonstrating the I in IO, as well as monad syntax:</span>\n<span class=\"token comment\">-- a function that fetches user input, prints it out and returns it.</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">::</span> <span class=\"token constant\">IO</span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">=</span>\n    <span class=\"token builtin\">putStrLn</span> <span class=\"token string\">\"Who?\"</span> <span class=\"token operator\">>></span>\n        <span class=\"token builtin\">getLine</span> <span class=\"token operator\">>>=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">name</span> <span class=\"token operator\">-></span>\n            <span class=\"token builtin\">putStrLn</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"Oh Hello \"</span> <span class=\"token operator\">++</span> <span class=\"token hvariable\">name</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span>\n                <span class=\"token builtin\">return</span> <span class=\"token hvariable\">name</span></code></pre></div>\n<p>The distinction with applicative functors is very slight.\n<strong>Most common functors are applicative and are monads</strong>, e.g.\n<code>[]</code>, <code>Maybe</code>, <code>State</code>, <code>IO</code></p>\n<p><a href=\"https://en.wikibooks.org/wiki/Haskell/do_notation\">do-blocks</a>\nare syntactic sugar to deal with monads, to do away with nesting. See below.</p>\n<h2>Syntax</h2>\n<p>To make a point about the syntax, all of these functions are exactly equivalent:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- list comprehension</span>\n<span class=\"token comment\">-- lists get their own special shorthand syntax, comprehensions like in Python.</span>\n<span class=\"token hvariable\">e1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">e1</span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">in</span>  <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">lst</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">lst</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">-- do-block: \"implicit\" (>>=)'s</span>\n<span class=\"token hvariable\">e2</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">e2</span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">do</span>\n    <span class=\"token hvariable\">x</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">lst</span>\n    <span class=\"token hvariable\">y</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">lst</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n    <span class=\"token builtin\">return</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- sugarless: binding monadic operations explicitly</span>\n<span class=\"token hvariable\">e3</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">e3</span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span> <span class=\"token keyword\">in</span>\n    <span class=\"token hvariable\">lst</span> <span class=\"token operator\">>>=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span>\n        <span class=\"token hvariable\">lst</span> <span class=\"token operator\">>>=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">y</span> <span class=\"token operator\">-></span>\n            <span class=\"token hvariable\">pure</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- maximum golf: remember (&lt;*>) :: Applicative f => f (a -> b) -> f a -> f b</span>\n<span class=\"token comment\">-- implicitly the &lt;$> bit is evaluated first to get a list of functions.</span>\n<span class=\"token hvariable\">e4</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">e4</span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">let</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span> <span class=\"token keyword\">in</span>\n    <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">y</span><span class=\"token punctuation\">,</span><span class=\"token hvariable\">c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token hvariable\">lst</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">lst</span></code></pre></div>\n<h2>Types and instances of functors et al</h2>\n<ul>\n<li><code>map :: (a -> b) -> [a] -> [b]</code>, literally <code>fmap</code> but just for lists</li>\n<li><code>fmap :: (a -> b) -> f a -> f b</code>, where f is a functor :@1</li>\n<li><code>(&#x3C;$>) :: (a -> b) -> f a -> f b</code>, where f is a functor</li>\n<li><code>pure :: a -> f a</code>, where f is an applicative functor</li>\n<li><code>(&#x3C;*>) :: f (a -> b) -> f a -> f b</code>, where f is an applicative functor</li>\n<li><code>(>>=) :: m a -> (a -> m b) -> m b</code>, where m is a monad</li>\n<li><code>(>>) :: m a -> m b -> m b</code>, where m is a monad</li>\n<li><code>return :: a -> m a</code>, where m is a monad</li>\n</ul>\n<p><a href=\"https://wiki.haskell.org/Lifting\">“lifting”</a>:\n<code>(->)</code> is right-applicative, so\n<code>fmap :: (a -> b) -> (f a -> f b)</code> is equivalent, and emphasises the “lift”,\nlikewise for <code>pure</code> et al.</p>\n<p>this is how lists are instances of Functor:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- [] here is A TYPE CONSTRUCTOR, i.e. the f in Functor f</span>\n<span class=\"token comment\">-- not the literal for an empty list.</span>\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span></code></pre></div>\n<p>and Maybe:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token constant\">Maybe</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Nothing</span></code></pre></div>\n<p>and Either:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Right</span> <span class=\"token hvariable\">b</span>\n\n<span class=\"token keyword\">instance</span> <span class=\"token constant\">Functor</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Either</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Right</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Right</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token builtin\">fmap</span> <span class=\"token hvariable\">f</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Left</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Left</span> <span class=\"token hvariable\">x</span></code></pre></div>\n<p><code>Either a</code> is a type constructor that takes 1 parameter, which is what the\nFunctor typeclass expects.</p>\n<p>Functions are in fact monads too:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">instance</span> <span class=\"token constant\">Applicative</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-></span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">r</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">pure</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">_</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n    <span class=\"token hvariable\">f</span> <span class=\"token operator\">&lt;*></span> <span class=\"token hvariable\">g</span> <span class=\"token operator\">=</span> <span class=\"token operator\">\\</span><span class=\"token hvariable\">x</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">f</span> <span class=\"token hvariable\">x</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">g</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">$</span> <span class=\"token number\">5</span>\n<span class=\"token number\">508</span></code></pre></div>\n<h2>In action</h2>\n<p>Golfing once again…</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- equivalently:</span>\n<span class=\"token comment\">-- getZipList $ fmap (+) (ZipList [1,2,3]) &lt;*> (ZipList [100,10,20])</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token hvariable\">getZipList</span> <span class=\"token operator\">$</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token constant\">ZipList</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;*></span> <span class=\"token constant\">ZipList</span> <span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">101</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">-- implicitly, this is (fmap &lt;$> [(+2,(*2))]) &lt;*> [Just 10, Just 20] :@1</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">fmap</span> <span class=\"token operator\">&lt;$></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;*></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Just</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Just</span> <span class=\"token number\">20</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">Just</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Just</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Just</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Just</span> <span class=\"token number\">40</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fmap</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;$></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Just</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Nothing</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Just</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token constant\">Just</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Nothing</span><span class=\"token punctuation\">,</span><span class=\"token constant\">Just</span> <span class=\"token number\">6</span><span class=\"token punctuation\">]</span></code></pre></div>\n<h2>Class constraints</h2>\n<p>Class constraints can appear in (type)class declarations vs instance\ndeclarations, as in <code>(Eq m) => Eq (classOrInstanceName m)</code>.</p>\n<ul>\n<li>In class declarations, they are used for making a typeclass a subclass of\nanother typeclass.</li>\n<li>In instance declarations, they are used to express requirements about the\ncontents of some type.</li>\n</ul>\n<p>For instance, we might require the contents of a Maybe, which is a concrete\ntype to also be part of the Eq typeclass. Note the Maybe is a type constructor.</p>\n<h2>Kinds</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Kind_(type_theory)\">Few languages</a>\nhave type systems that allow access to higher-kinded types (e.g. Monads).\nHaskell lets you see the kinds of types too. I have yet to realise where\nthis might be useful.</p>\n<p>Kinds are to types what types are to values. Find out kind of a type with\n<code>:k</code> in GHCi.</p>\n<p><code>*</code> means concrete type:</p>\n<ul>\n<li><code>Int :: *</code></li>\n<li><code>Maybe :: * -> *</code></li>\n<li><code>Maybe Int :: *</code></li>\n<li><code>Either :: * -> * -> *</code></li>\n</ul>\n<p>I haven’t quite grasped this, but it’s interesting regardless:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">class</span> <span class=\"token constant\">Tofu</span> <span class=\"token hvariable\">t</span> <span class=\"token keyword\">where</span>\n    <span class=\"token hvariable\">tofu</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">j</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">t</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">j</span></code></pre></div>\n<p>If <code>t</code> is an instance of <code>Tofu</code>, what would its kind be?</p>\n<ul>\n<li><code>j a</code> is the type of the value of the first parameter of <code>tofu</code>, so\nits kind must be <code>*</code>, i.e. it is a concrete type.</li>\n<li>Assuming <code>a</code> is of kind <code>*</code>, <code>j</code> has kind <code>* -> *</code>.</li>\n<li><code>t a j</code> must be a concrete type, and since it takes two types <code>a</code> and <code>j</code>,\nwhose kinds we inferred above, <code>t</code> has kind <code>* -> (* -> *) -> *</code>.</li>\n</ul>\n<p>So, <code>t</code> takes a concrete type <code>a</code>, a type constructor <code>j</code> that takes a concrete\ntype, and produces a concrete type.</p>","frontmatter":{"title":"Monads, Applicatives, and Functors in Haskell","date":"October 07, 2020","description":"A summary of monads, applicatives, and functors in Haskell."}},"previous":{"fields":{"slug":"/new-beginnings/"},"frontmatter":{"title":"New Beginnings"}},"next":{"fields":{"slug":"/a-sudoku-solver-in-15-lines-of-prolog/"},"frontmatter":{"title":"A Sudoku Solver in 15 Lines of Prolog"}}},"pageContext":{"id":"b92cb5e3-d5fd-532f-bb02-374ab3477e3f","previousPostId":"ec0add8c-fde4-5c0c-82e0-61e982738be2","nextPostId":"c1755bc9-3c36-54c1-8753-d853166fc885"}},"staticQueryHashes":["2841359383"]}