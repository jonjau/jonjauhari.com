---
title: "Engineers and Developers"
date: "2022-02-20T18:22:55+11:00"
description: "What comes to mind?"
---

Once, my friend told me that there was a 'financial engineering' subject
taught at my university and that he really wanted to take it. My immediate
reaction was to laugh as it sounded absurd, and somehow nefarious.

He did seem like the kind of guy who would love to work behind 6 or so
monitors trading in *((exotic))* financial instruments for the fun of it.

> In fact I had been taking an introductory finance class (in person!) at
> that time, and my newly-formed intuition was that in the thing called
> Finance, KISS holds, and "engineered" complexity only invites middlemen and
> fraudulence...

Coming back to that moment a few times, I realised I was the weirdo. The
subject name was simply using 'engineering' with a slightly different meaning,
obviously not the kind with hard hats. That divergence in meaning caused me
to inspect another more commonly-used term more familiar to me: Software
Engineering.

For me, 'engineering' has always felt off for what I've seen software
engineers actually do. My preference for the term *'software development'*
over *'software engineering'* in most cases has now led me to write a lot of
paragraphs to question the nature of the profession from the microscopic bit
of experience that I've had in it. Beginners and bikeshedding do go hand
in hand, but Dijkstra writing about computing's "radical novelties" and
the misuse of terms probably indicates that the situation is indeed not
ideal.

My room-temperature take is that there are fundamental differences that set
software engineering apart from the other branches of engineering -- with
which I am even less familiar -- to warrant a different term.

## Similarity in methodologies

There are clearly similarities between the main engineering branches (civil,
mechanical, electrical, etc.) and software engineering.

In approaching the problem, the high-level steps taken are similar, including:

- understanding requirements, constraints, risks
- designing solutions
- evaluating solutions
- testing solutions
- realise the best solution in production
- maintaining the product

Easily, you could say that there are transferrable skills between the
branches: in problem solving and more importantly, understanding problems then
communicating that understanding to others.

But literally all professions deal with solving problems and being able to
communicate about them. Dictionary definitons suggest that the emphasis on the
underlying scientific principles and technologies being used is key. There are
bonus points if the end product is a machine, structure, or tool.

> It's interesting to think about what distinguishes a modern
> farmer from an agricultural engineer, or a worker in a high-tech factory
> from a mechanical engineer. It seems to be the different expectations in
> academic credentials, broadness of technical knowledge, and to some extent,
> closeness to the production process.

I don't know enough about the other branches to comment on specifics, but from
the single introductory subject that I took which was labelled engineering
where we had to calibrate a catapult to hit a target, the knowledge base of
physics calculations, materials, and software tools very much paralleled
logic, programming language syntax, and developer tools in my introduction to
programming course.

So in software engineering, just as in the other branches, there is problem
solving, with technology and scientific principles always being used, for
instance with logic, algebra and computational complexity. At this high level
of abstraction, the discipline deserves its name.

Of course, when we get more practical there are differences that set software
engineering apart. One is the difference in educational expectations.
Arguably there are many more pathways (shortcuts!) to get the professional
title 'Software Engineer', than there are to get 'Mechanical Engineer'.

## Difference in constraints

As I see it, the fundamental difference is in the constraints of the problem
domain, and not just in the sense of analog versus digital. Simply put,
software engineering is not engineering because its problem domain is
virtually separate from the physical world.

Whereas in most other branches of engineering there are forces of nature to
constantly contend with, such as gravity, molecular bonds, or radiation, on
top of the human factor, the only physical things people contend with in
software engineering are time and human minds. Perhaps it's even human
impatience, rather than time that is a constraint. It sits squarely in the
human world, solving human problems with human solutions, considering
only human contraints.

What about the hardware that the software runs? The keyboards, computers,
wires, and robotic arms... surely problems in that domain would fall under
more proper branches of engineering: mechanical, electronic, electric,
mechatronics. The moment you hit the physical bits and bobs that breathe life
into your "Hello World", you would be beyond the borders of "Software
Engineering".

What if the software being engineered is to be applied to a problem in the
physical world, say, to control generators in a dam? In that case, the problem
(and the solution) would have been detailed by the dam engineer. We are
dealing with a person's words and diagrams as a starting point. Otherwise, if
the software engineer is expected to solve that problem as well, then they
would be, maybe literally, wearing two hats.

The important human constraint is aversity to complex information, that it
takes time and effort to understand complex things. It can be argued that
computational complexity is a "natural" thing, but in producing software we
really only consider the cognition of the average human.

The scarcity of physical constraints in the problem domain of software
engineering leads to the main constraint being centered around
**communication** -- the exchange of information.

## Communication

That malleability of software makes it much easier to overengineer, i.e. 
coming up with complex solutions when simpler ones would do.

But it
is actually human nature that makes it *necessary* to overengineer, in the
sense that we ought to program in well-documented C, or, even better, write
code in "runnable pseudocode" Python that calls C libraries, rather than
trudge through machine code, in order to reduce the cognitive load on the
next developer

We see this manifest too in the way programming is taught. The allure of
teaching inheritance with animals, woofing dogs and meowing cats...

Not only is this misleading in teaching how inheritance is used, but it also
suggests that software engineering having to do with anything physical by
default.

When [random large percentage] of the time we are simply modelling abstract
concepts, whether it's UI elements in a desktop application, different
database adapters for a CRUD web service, or some business object whose
technicalities perpetually change. Sure, using pet animals makes it fun and
less context-dependent, but my impression was that engineer-type folks pride
themselves on keeping it light on theory and tight on application.

The truth is, outside the realm of robotics or developing simulations, for
instance those in video games, the bulk of the work labelled as 'software
development' seems to be dealing with information. And dealing with
information, means 

A fundamental difference:
the main constraint is communication, instead of physical limitations (which
effectively do not exist)

We must

two schools of thought, UNIX and electron crowd

## The Extended Stack

In software development, web development in particular, there is a thing where
one would quote the shiny techonologies they use, perhaps to signal tech-forwardness

Almost as if they were personality traits...

some of these stacks are so commonly-used, they are crystallised as acronyms
used in job requirements, such as LAMP, MEAN, or MERN.

The "stack" of technologies, as in "full-stack engineer", does not end at
whether you use React or Vue, or even AWS or Azure, but it's interesting to
think that the communication of concepts that sits atop these layers is a
technology in itself.

That English is the

link to prolog code

To stretch it even further, we can even think of trends we see in software
development

Another clear parallel is that between legal code and actual code, smart
contracts

the emails that we send, the standup meetings and 

it might explain why the entire world clings so dearly to the word
"Agile", as it is a vital name-tag for an improved process of communication
whose effects can outweigh any choice of 'actual' technology.

In the end, the ultimate communication tool is unambiguous language

The world's choice of technology however, is English. Legacy tech, really. 

It makes a poor programming language, then again its duties go far beyond
describing FizzBuzz.

After all, it is information all the way down

Fully within the human world

There is no force of nature involved. Remember, the moment you hit the
physical electronic bits and bobs that breathe life into your "Hello World",
you are far beyond the borders of "Software Engineering".

By nature,
software is built upon layers and layers of abstraction, The "tools" we
"invent" are not to conquer, say, gravitational limitations, but simply to conquer
our aversity to complex information systems.

A core idea is that of abstracting complexity

By the same token, it is equally easy to oversimplify: the fewer levers to
fiddle with, the harder it is to get a handle (literally) on what's going on.
An immediate example would be list comprehensions in Python hiding
computational complexity, and being harder to debug.

I think it doesn't help that
The lower barrier of entry coupled with the half-false "prestige" that
the title of "engineer", as well as the very-real high salaries the
career path promises, tends to brew overconfidence

A unique concept in software engineering is version control

don't forget hardware.

unlike a bridge, software products can improve without the developers knowing
compilers do a lot of heavy lifting. Bad code with good libs run OK.

A side effect of no physical constraints
Information, by nature sits atop other

## Who cares?

naming is all we have, so why not try that here?

some words are bubbling up: coding, programming, developing, engineering,
architecting

logistician

many roles to play: communicating, designing, developing, refactoring,
deploying, testing

The relative youth of the discipline helps here. Beyond slapping e- in front
of nouns

buzzwords come and go

e-sports and sports

Surely we can 'engineer' some terms to fit our needs.

- term hijacking
- fundamental difference: engineering vs developing
- main constraint: communication
- layers of abstraction: necessary evil
- extended stack
- the layers are malleable: your code changing without you knowing
- a symptom of its youth: layers changing so quickly, terms coming and going
- myriad consequences of term misuse, overconfidence, python and C elitist
- so what? more wordsmithing, designer sounds better






Where in electrical engineering, one may create/modify software to interface
with some hardware, i.e. it being a means to an end, software engineering is
wholly concerned about that process, making the software as robust as
possible, and at times to the detriment of commercial deadlines or 

In particular, data science has a vastly different set of constraints, to the
point where, even if the tools are the same, it is not software development.

I've always thought programming as an activity shares more in common with
linguistics than it does with mathematics

Part of a trend of appropriating terms originally for physical objects to
describe software products or digital concepts, prefix e in front of
everything, but we grew out of that quickly, there is no e-cloud, electric or
electronic? digital virtual meta.

We could make up words instead: firewall, metaverse, devops