---
title: "Engineers and Developers"
date: "2022-02-20T18:22:55+11:00"
description: "We need more words, and better ones..."
---

Once, I heard that there was a 'financial engineering' subject taught at
my university. My immediate reaction was to laugh as it sounded absurd, and
somehow nefarious. In fact, I had been taking an introductory finance class
(in person!) at that time, and my intuition was that in the thing called
Finance, complexity only invites fraudulence and middlemen...

Coming back to that moment a few times, I realised I was the weirdo. The
subject name was simply using 'engineering' in a slightly different meaning,
obviously not the kind with hard hats. It is used the way it's used in
'Software Engineering' -- a subtle divergence in meaning I think we could do
without.


I've always found it odd that 'Software Engineer' is a legitimate term.

I always thought it sounded too 'good'

never found it fitting for what I've seen

do not deal with physical systems, does not fit common definitions of 
engineering

Another little bit of term-hijacking that we could do without.

Part of a trend of appropriating terms originally for physical objects to
describe software products or digital concepts, prefix e in front of
everything, but we grew out of that quickly, there is no e-cloud, electric or
electronic? digital virtual meta.

We could make up words instead: firewall, metaverse, devops

We see this manifest too in the way programming is taught. The allure of
teaching inheritance with animals, woofing dogs and meowing cats...

Not only is this misleading in teaching how inheritance is used, but also
hints at software engineering having to do with anything physical.

When 90% of the time we are simply modelling abstract concepts. Whether it is
UI elements in a desktop application, Different database adapters for a CRUD
web service,

The truth is, outside of realm of developing simulations, for instance those
in video games, the bulk of the work labelled as 'software development' seems
to be  

The similarities and differences between classical engineering and this
wannabe discipline.

A fundamental difference:
the main constraint is communication, instead of physical limitations (which
effectively do not exist)

That malleability of software makes it much easier to overengineer. But it
is actually human nature that makes it *necessary* to overengineer, in the
sense that we ought to program in well-documented C, or, even better, write
code in "runnable pseudocode" Python that calls C libraries, rather than
trudge through 

### The extended stack

The "stack" of technologies, as in "full-stack engineer", does not end at
whether you use React or Vue, or even AWS or Azure, but it can be said that
the communication of concepts that sits atop these pieces is a technology in
itself.

the emails that we send, the standup meetings and 

it might explain why the entire world clings so dearly to the word
"Agile", as it is a vital name-tag for an improved process of communication
whose effects can outweigh any choice of 'hard' technology.

In the end, the ultimate communication tool is unambiguous language

The world's choice of technology however, is English. Legacy tech, really. 

It makes a poor programming language, then again its duties go far beyond
describing FizzBuzz.

After all, it is information all the way down 

Fully within the human world

There is no force of nature involved. Remember, the moment you hit the
physical electronic bits and bobs that breathe life into your "Hello World",
you are far beyond the borders of "Software Engineering".

By nature,
software is built upon layers and layers of abstraction, The "tools" we
"invent" are not to conquer, say, gravitational limitations, but simply to conquer
our aversity to complex information systems.

A core idea is that of abstracting complexity

By the same token, it is equally easy to oversimplify: the fewer levers to
fiddle with, the harder it is to get a handle (literally) on what's going on.
An immediate example would be list comprehensions in Python hiding
computational complexity, and being harder to debug.

I think it doesn't help that
The lower barrier of entry coupled with the half-false "prestige" that
the title of "engineer", as well as the very-real high salaries the
career path promises, tends to brew overconfidence

A unique concept in software engineering is version control

don't forget hardware.

unlike a bridge, software products can improve without the developers knowing
compilers do a lot of heavy lifting. Bad code on good boxes run OK.

even more term overloading: machine learning and business intelligence.

some words are bubbling up: coding, programming, developing, engineering,
architecting

many roles to play: communicating, designing, developing, refactoring,
deploying, testing
