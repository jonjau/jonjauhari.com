---
title: "Engineers and Developers"
date: "2022-02-20T18:22:55+11:00"
description: "What comes to mind?"
---

Once, my friend told me that there was a 'financial engineering' subject
taught at my university and that he really wanted to take it. My immediate
reaction was to laugh as it sounded absurd, and somehow nefarious. Then again,
he did seem like the kind of guy who would love to work behind 6 or so
monitors trading in ((*exotic*)) financial instruments for the fun of it.

In fact, I had been taking an introductory finance class (in person!) at that
time, and my intuition was that in the thing called Finance, KISS holds, and
complexity only invites middlemen and fraudulence...

Coming back to that moment a few times, I realised I was the weirdo. The
subject name was simply using 'engineering' in a slightly different meaning,
obviously not the kind with hard hats. It is used the way it's used in
'Software Engineering' -- a subtle divergence in meaning I think we could do
without.

For me, the word has always felt off for what

and I think

and this led to me question the nature of the entire profession from the
little experience that I've had in it, and why I 

## Similarity in methodologies

Why was the

transferrable skills in problem solving and more importantly, understanding
problems then communicating that understanding to others (next part...)

I don't know enough about other disciplines to comment on specifics, but
from the single subject that I took which was labelled engineering,

Certified profession and not, but I don't consider that to be the fundamental
difference

## Difference in constraints

exchange of information

Where in electrical engineering, one may create/modify software to interface
with some hardware, i.e. it being a means to an end, software engineering is
wholly concerned about

I've always thought programming as an activity shares more in common with
linguistics than it does with mathematics

do not deal with physical systems, does not fit common definitions of
engineering

Part of a trend of appropriating terms originally for physical objects to
describe software products or digital concepts, prefix e in front of
everything, but we grew out of that quickly, there is no e-cloud, electric or
electronic? digital virtual meta.

We could make up words instead: firewall, metaverse, devops

## Physical aspirations

We see this manifest too in the way programming is taught. The allure of
teaching inheritance with animals, woofing dogs and meowing cats...

Not only is this misleading in teaching how inheritance is used, but it also
suggests that software engineering having to do with anything physical by
default.

When [random large percentage] of the time we are simply modelling abstract
concepts, whether it's UI elements in a desktop application, different
database adapters for a CRUD web service, or some business object whose
technicalities perpetually change.

The truth is, outside the realm of robotics or developing simulations, for
instance those in video games, the bulk of the work labelled as 'software
development' seems to be dealing with information. And dealing with
information, means 

A fundamental difference:
the main constraint is communication, instead of physical limitations (which
effectively do not exist)

That malleability of software makes it much easier to overengineer. But it
is actually human nature that makes it *necessary* to overengineer, in the
sense that we ought to program in well-documented C, or, even better, write
code in "runnable pseudocode" Python that calls C libraries, rather than
trudge through

## The Extended Stack

In software development, web development in particular, people love to quote
the shiny techonologies they use, perhaps as a sign of tech-forwardness

some of these stacks 

The "stack" of technologies, as in "full-stack engineer", does not end at
whether you use React or Vue, or even AWS or Azure, but it can be said that
the communication of concepts that sits atop these layers is a technology in
itself.

That English is the

link to prolog code

To stretch it even further, we can even think of trends we see in software
development

Another clear parallel is that between legal code and actual code, smart
contracts

the emails that we send, the standup meetings and 

it might explain why the entire world clings so dearly to the word
"Agile", as it is a vital name-tag for an improved process of communication
whose effects can outweigh any choice of 'actual' technology.

In the end, the ultimate communication tool is unambiguous language

The world's choice of technology however, is English. Legacy tech, really. 

It makes a poor programming language, then again its duties go far beyond
describing FizzBuzz.

After all, it is information all the way down

Fully within the human world

There is no force of nature involved. Remember, the moment you hit the
physical electronic bits and bobs that breathe life into your "Hello World",
you are far beyond the borders of "Software Engineering".

By nature,
software is built upon layers and layers of abstraction, The "tools" we
"invent" are not to conquer, say, gravitational limitations, but simply to conquer
our aversity to complex information systems.

A core idea is that of abstracting complexity

By the same token, it is equally easy to oversimplify: the fewer levers to
fiddle with, the harder it is to get a handle (literally) on what's going on.
An immediate example would be list comprehensions in Python hiding
computational complexity, and being harder to debug.

I think it doesn't help that
The lower barrier of entry coupled with the half-false "prestige" that
the title of "engineer", as well as the very-real high salaries the
career path promises, tends to brew overconfidence

A unique concept in software engineering is version control

don't forget hardware.

unlike a bridge, software products can improve without the developers knowing
compilers do a lot of heavy lifting. Bad code with good libs run OK.

## Who cares?

some words are bubbling up: coding, programming, developing, engineering,
architecting

many roles to play: communicating, designing, developing, refactoring,
deploying, testing

The relative youth of the discipline helps here. Beyond slapping e- in front
of nouns

buzzwords come and go

e-sports and sports

Surely we can 'engineer' some terms to fit our needs.

- term hijacking
- fundamental difference: engineering vs developing
- main constraint: communication
- layers of abstraction: necessary evil
- extended stack
- the layers are malleable: your code changing without you knowing
- a symptom of its youth: layers changing so quickly, terms coming and going
- myriad consequences of term misuse, overconfidence, python and C elitist
- so what? more wordsmithing, designer sounds better
